{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Real-Time Audio DSP on FPGA Have you ever wanted to take your embedded audio DSP projects to the next level? Imagine being able to benefit from unparalleled audio latency performances and computational power , all while using an accessible programming language . Or maybe you just want to be able to use a huge number of microphones and speakers with ultra-fast audio processing? Well, you're in luck! Come discover Syfala : the first open-source audio DSP compiler targeting FPGAs using the Faust programming language . We'll cover everything from the basics of FPGA programming to the syntax and concepts to use Faust on an embedded platform. We'll show you how to create your own Faust DSP for real time audio processing, and control it with a baremetal system or an embedded Linux. So come join us for this hands-on workshop ! Let's explore the world of FPGAs together and see what amazing audio processing capabilities we can create! Description Field-Programmable Gate Arrays (FPGAs) provide unparalleled audio latency and computational power . This makes them a better fit for real-time audio processing than traditional CPUs for many applications. These embedded platforms can easily handle DSPs with thousand of channels while guaranteeing very low latency . You can imagine some very advanced applications in spatial audio, noise cancelling or active control of room acoustics . For exemple, the combination of a large number of microphones and speakers with ultra-fast audio processing could permit to actively modify the acoustical properties of rehearsal spaces, concert halls, etc., to make them sound like a cathedral or any famous venue in the world. It also provides opportunities for new musical discoveries and investigations , like using very high audio sampling rate to generate digital oscillator, approximating analog. However, programming them is very complex and out of reach to non-specialized engineers as well as to most people in the audio community. That's where Faust comes to the rescue! Faust is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. Programming FPGAs with Faust will allow you to explore the power of FPGAs while leveraging an accessible programming language that's widely used within the audio community. Using a Zybo ARM/FPGA SoC Development Board which can be provided to you as part of a lab kit, you will learn how to easily program your own Faust audio signal processing applications on an embedded Linux environment offering the unmatched performances of an FPGA. Covered topics During this course, as an introduction to FPGAs, we will first describe in details the ins and outs of this platform : how they work, their general purpose, and why they are a great fit for audio hardware and software development. We will dive in audio development on FPGAs using Syfala to compile our first baremetal audio programs from regular Faust DSP code . We will then generate a graphical user interface (GUI) to control it in real-time. Finally, we will demonstrate how to build and use a custom-made embedded Linux distribution directly on the board . This will allow us to use more advanced control protocols such as MIDI , Open Sound Control ( OSC ), HTTP , etc. By the end of the workshop, you should have a good understanding of the possibilities that such a platform affords in the context of real-time audio processing. Instructors Maxime Popoff -- Computer Science and Embedded Systems PhD Student, Emeraude Team -- INSA Lyon (France) Pierre Cochard -- Research engineer, Emeraude Team -- Inria Lyon (France) Feel free to contact us for any additional information ! Requirements This workshop is intended for musicians, makers, engineers, computer scientists, etc. Previous background in computer programming and sound synthesis/processing is preferred. Hardware Participants should bring their own laptop. The following elements - which can be purchased for them and added to the registration fee - are also required for the workshop: a Digilent Zybo Z7-10 or Z7-20 ARM/FPGA SoC Development Board an external 4.5 to 5.5V / 2.5A+ power source a microUSB-USB cable a 4GB (minimum) micro SD card required for the embedded Linux an USB-MIDI controller , with at least a few knobs and keys or pads. Software During the workshop, we will extensively use the AMD-Xilinx 2022.2 toolchain . If you have a debian-based operating system (Ubuntu, Linux Mint...) already installed on your machine, feel free to install the toolchain by yourself prior to the workshop, following the instructions provided here . For any other Linux distributions , but also macOS ( x86 ), a container-image can be provided, it will require the installation of one of these two softwares : podman (multi-platform, installation instructions are available here ) docker (multi-platform, installation instructions are available here ) Unfortunately, syfala containers are at the moment not working on ARM-based macOS systems, and have not been tested on Windows .","title":"Home"},{"location":"#real-time-audio-dsp-on-fpga","text":"Have you ever wanted to take your embedded audio DSP projects to the next level? Imagine being able to benefit from unparalleled audio latency performances and computational power , all while using an accessible programming language . Or maybe you just want to be able to use a huge number of microphones and speakers with ultra-fast audio processing? Well, you're in luck! Come discover Syfala : the first open-source audio DSP compiler targeting FPGAs using the Faust programming language . We'll cover everything from the basics of FPGA programming to the syntax and concepts to use Faust on an embedded platform. We'll show you how to create your own Faust DSP for real time audio processing, and control it with a baremetal system or an embedded Linux. So come join us for this hands-on workshop ! Let's explore the world of FPGAs together and see what amazing audio processing capabilities we can create!","title":"Real-Time Audio DSP on FPGA"},{"location":"#description","text":"Field-Programmable Gate Arrays (FPGAs) provide unparalleled audio latency and computational power . This makes them a better fit for real-time audio processing than traditional CPUs for many applications. These embedded platforms can easily handle DSPs with thousand of channels while guaranteeing very low latency . You can imagine some very advanced applications in spatial audio, noise cancelling or active control of room acoustics . For exemple, the combination of a large number of microphones and speakers with ultra-fast audio processing could permit to actively modify the acoustical properties of rehearsal spaces, concert halls, etc., to make them sound like a cathedral or any famous venue in the world. It also provides opportunities for new musical discoveries and investigations , like using very high audio sampling rate to generate digital oscillator, approximating analog. However, programming them is very complex and out of reach to non-specialized engineers as well as to most people in the audio community. That's where Faust comes to the rescue! Faust is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. Programming FPGAs with Faust will allow you to explore the power of FPGAs while leveraging an accessible programming language that's widely used within the audio community. Using a Zybo ARM/FPGA SoC Development Board which can be provided to you as part of a lab kit, you will learn how to easily program your own Faust audio signal processing applications on an embedded Linux environment offering the unmatched performances of an FPGA.","title":"Description"},{"location":"#covered-topics","text":"During this course, as an introduction to FPGAs, we will first describe in details the ins and outs of this platform : how they work, their general purpose, and why they are a great fit for audio hardware and software development. We will dive in audio development on FPGAs using Syfala to compile our first baremetal audio programs from regular Faust DSP code . We will then generate a graphical user interface (GUI) to control it in real-time. Finally, we will demonstrate how to build and use a custom-made embedded Linux distribution directly on the board . This will allow us to use more advanced control protocols such as MIDI , Open Sound Control ( OSC ), HTTP , etc. By the end of the workshop, you should have a good understanding of the possibilities that such a platform affords in the context of real-time audio processing.","title":"Covered topics"},{"location":"#instructors","text":"Maxime Popoff -- Computer Science and Embedded Systems PhD Student, Emeraude Team -- INSA Lyon (France) Pierre Cochard -- Research engineer, Emeraude Team -- Inria Lyon (France) Feel free to contact us for any additional information !","title":"Instructors"},{"location":"#requirements","text":"This workshop is intended for musicians, makers, engineers, computer scientists, etc. Previous background in computer programming and sound synthesis/processing is preferred.","title":"Requirements"},{"location":"#hardware","text":"Participants should bring their own laptop. The following elements - which can be purchased for them and added to the registration fee - are also required for the workshop: a Digilent Zybo Z7-10 or Z7-20 ARM/FPGA SoC Development Board an external 4.5 to 5.5V / 2.5A+ power source a microUSB-USB cable a 4GB (minimum) micro SD card required for the embedded Linux an USB-MIDI controller , with at least a few knobs and keys or pads.","title":"Hardware"},{"location":"#software","text":"During the workshop, we will extensively use the AMD-Xilinx 2022.2 toolchain . If you have a debian-based operating system (Ubuntu, Linux Mint...) already installed on your machine, feel free to install the toolchain by yourself prior to the workshop, following the instructions provided here . For any other Linux distributions , but also macOS ( x86 ), a container-image can be provided, it will require the installation of one of these two softwares : podman (multi-platform, installation instructions are available here ) docker (multi-platform, installation instructions are available here ) Unfortunately, syfala containers are at the moment not working on ARM-based macOS systems, and have not been tested on Windows .","title":"Software"},{"location":"resources/","text":"Installing syfala and the Xilinx 2022.2 toolchain ( debian-based operating systems only ) Running and using the syfala container (other operating systems) Getting started with syfala Syfala reference","title":"Resources"},{"location":"syfala-getting-started/","text":"Getting started Hardware setup (Digilent Zybo-Z7-10/20 boards) [x] Jumper JP5 should be on JTAG [x] Power select jumper should be on USB [x] Switches SW0, SW1, SW2, SW3 should be down [x] The audio input is LINE IN (blue), not MIC IN [x] The audio output is the black HPH OUT jack Software Building a simple example for the default board (Digilent Zybo Z7-10) : $ syfala examples/virtualAnalog.dsp This will run the full syfala toolchain on the virtualAnalog.dsp Faust file, which will then be ready to be flashed on the board. Y ou can specify the targeted board using the -b (--board) option: $ syfala examples/virtualAnalog.dsp --board Z20 $ syfala examples/virtualAnalog.dsp --board GENESYS You can now connect the board to your computer with the proper USB/Serial port cable and run the flash command: $ syfala flash The board's RGB LED should then become green after a few seconds, indicating that your program is running. You can now start the Faust GUI application , which will display a set of sliders/knobs/buttons and update the DSP parameters in real-time through USB-UART : $ syfala gui Exporting and re-importing your builds When you're done playing with your program, you can save and export it as a .zip file with the following command: $ syfala export my-virtual-analog-build # the exported .zip file is tagged with date & time, e.g.: >> \"export/2022-02-17-my-virtual-analog-build.zip\" The resulting .zip file is now available in the repository's export directory, you can re-import it by typing: $ syfala import export/2022-02-17-my-virtual-analog-build.zip Making another build Before building another DSP program, please make sure you have saved and exported your previous build beforehand, otherwise it will be overwritten whenever you start a new build. # Clean build directory & start another build: $ syfala clean $ syfala examples/my-new-dsp-build.dsp # Both commands can also be combined by adding the '--reset' flag $ syfala examples/my-new-dsp-build.dsp --reset Going further Please report to the reference for more information on available commands , options and documentation.","title":"Syfala getting started"},{"location":"syfala-getting-started/#getting-started","text":"","title":"Getting started"},{"location":"syfala-getting-started/#hardware-setup-digilent-zybo-z7-1020-boards","text":"[x] Jumper JP5 should be on JTAG [x] Power select jumper should be on USB [x] Switches SW0, SW1, SW2, SW3 should be down [x] The audio input is LINE IN (blue), not MIC IN [x] The audio output is the black HPH OUT jack","title":"Hardware setup (Digilent Zybo-Z7-10/20 boards)"},{"location":"syfala-getting-started/#software","text":"Building a simple example for the default board (Digilent Zybo Z7-10) : $ syfala examples/virtualAnalog.dsp This will run the full syfala toolchain on the virtualAnalog.dsp Faust file, which will then be ready to be flashed on the board. Y ou can specify the targeted board using the -b (--board) option: $ syfala examples/virtualAnalog.dsp --board Z20 $ syfala examples/virtualAnalog.dsp --board GENESYS You can now connect the board to your computer with the proper USB/Serial port cable and run the flash command: $ syfala flash The board's RGB LED should then become green after a few seconds, indicating that your program is running. You can now start the Faust GUI application , which will display a set of sliders/knobs/buttons and update the DSP parameters in real-time through USB-UART : $ syfala gui","title":"Software"},{"location":"syfala-getting-started/#exporting-and-re-importing-your-builds","text":"When you're done playing with your program, you can save and export it as a .zip file with the following command: $ syfala export my-virtual-analog-build # the exported .zip file is tagged with date & time, e.g.: >> \"export/2022-02-17-my-virtual-analog-build.zip\" The resulting .zip file is now available in the repository's export directory, you can re-import it by typing: $ syfala import export/2022-02-17-my-virtual-analog-build.zip","title":"Exporting and re-importing your builds"},{"location":"syfala-getting-started/#making-another-build","text":"Before building another DSP program, please make sure you have saved and exported your previous build beforehand, otherwise it will be overwritten whenever you start a new build. # Clean build directory & start another build: $ syfala clean $ syfala examples/my-new-dsp-build.dsp # Both commands can also be combined by adding the '--reset' flag $ syfala examples/my-new-dsp-build.dsp --reset","title":"Making another build"},{"location":"syfala-getting-started/#going-further","text":"Please report to the reference for more information on available commands , options and documentation.","title":"Going further"},{"location":"syfala-installation/","text":"Installing syfala on Ubuntu The Syfala toolchain is a compilation toolchain of Faust programs onto AMD-Xilinx FPGA targets. This document explains how to install and run the version 0.7.1 of the toolchain on a Linux machine. In practice, installing the Syfala toolchain means: Installing the required linux-packages Installing the Faust compiler Creating a AMD-Xilinx account and downloading/installing the 2022.2 version of the AMD-Xilinx toolchain (providing softwares such as Vivado, Vitis, Vitis HLS). Installing the additionnal Vivado Board Files for Digilent Boards. Installing udev rules in order to use the JTAG connection. Cloning the Syfala repository , and running a simple example to make sure everything is working properly. Dependencies Packages $ sudo apt-get update $ sudo apt-get install libncurses5 libtinfo-dev g++-multilib gtk2.0 Faust It is recommended to clone Faust from the official github repository : $ git clone https://github.com/grame-cncm/faust.git $ cd faust $ make $ sudo make install Vivado, Vitis & Vitis HLS (2022.2 version) Open an account on https://www.xilinx.com/registration The Xilinx download page ( https://www.xilinx.com/support/download.html ) contains links for downloading the \"Vivado Design Suite - HLx Editions - Full Product\". It is available for both Linux and Windows. Download the Linux installer Xilinx_Unified_2022.2_1014_8888_Lin64.bin execute chmod a+x Xilinx_Unified_2022.2_1014_8888_Lin64.bin execute ./Xilinx_Unified_2022.2_1014_8888_Lin64.bin We suggest to use the \"Download Image (Install Separately)\" option. It creates a directory with a xsetup file to execute that you can reuse in case of failure during the installation execute ./xsetup Choose to install Vitis (it will still install Vivado , Vitis , and Vitis HLS ). It will need 110GB of disk space: if you uncheck Ultrascale , Ultrascale+ , Versal ACAP and Alveo acceleration platform , it will use less space and still work. Agree with everything and choose a directory to install (e.g. ~/Xilinx) Install and wait for hours... Setup a shell environment variable allowing to use the tools when necessary (add this to your ~/.bashrc , ~/.zshrc or whatever you're currently using, replacing $HOME/Xilinx by the directory you chose to install all the tools) export XILINX_ROOT_DIR=$HOME/Xilinx Installing Cable Drivers on Linux go to: $XILINX_ROOT_DIR/Vivado/2022.2/data/xicom/cable_drivers/lin64/install_script/install_drivers directory run ./install_drivers run sudo cp 52-xilinx-digilent-usb.rules /etc/udev/rules.d , this allows JTAG connection through USB . Installing Digilent Board Files Download the board files here Open the folder extracted from the archive and navigate to its new/board_files folder. You will be copying all of this folder's subfolders go to $XILINX_ROOT_DIR/Vivado/2022.2/data/xhub/boards/XilinxBoardStore/boards/Xilinx Copy all of the folders found in vivado-boards new/board_files folder and paste them into this folder Cloning the Syfala repository To clone and install the latest stable version of the Syfala toolchain, you can use the following commands: $ git clone https://github.com/inria-emeraude/syfala $ cd syfala $ ./syfala.tcl install $syfala --help In order to use the Syfala toolchain to compile your first example, please report to the main README file located in the repository's root directory.","title":"Installing syfala on Ubuntu"},{"location":"syfala-installation/#installing-syfala-on-ubuntu","text":"The Syfala toolchain is a compilation toolchain of Faust programs onto AMD-Xilinx FPGA targets. This document explains how to install and run the version 0.7.1 of the toolchain on a Linux machine. In practice, installing the Syfala toolchain means: Installing the required linux-packages Installing the Faust compiler Creating a AMD-Xilinx account and downloading/installing the 2022.2 version of the AMD-Xilinx toolchain (providing softwares such as Vivado, Vitis, Vitis HLS). Installing the additionnal Vivado Board Files for Digilent Boards. Installing udev rules in order to use the JTAG connection. Cloning the Syfala repository , and running a simple example to make sure everything is working properly.","title":"Installing syfala on Ubuntu"},{"location":"syfala-installation/#dependencies","text":"","title":"Dependencies"},{"location":"syfala-installation/#packages","text":"$ sudo apt-get update $ sudo apt-get install libncurses5 libtinfo-dev g++-multilib gtk2.0","title":"Packages"},{"location":"syfala-installation/#faust","text":"It is recommended to clone Faust from the official github repository : $ git clone https://github.com/grame-cncm/faust.git $ cd faust $ make $ sudo make install","title":"Faust"},{"location":"syfala-installation/#vivado-vitis-vitis-hls-20222-version","text":"Open an account on https://www.xilinx.com/registration The Xilinx download page ( https://www.xilinx.com/support/download.html ) contains links for downloading the \"Vivado Design Suite - HLx Editions - Full Product\". It is available for both Linux and Windows. Download the Linux installer Xilinx_Unified_2022.2_1014_8888_Lin64.bin execute chmod a+x Xilinx_Unified_2022.2_1014_8888_Lin64.bin execute ./Xilinx_Unified_2022.2_1014_8888_Lin64.bin We suggest to use the \"Download Image (Install Separately)\" option. It creates a directory with a xsetup file to execute that you can reuse in case of failure during the installation execute ./xsetup Choose to install Vitis (it will still install Vivado , Vitis , and Vitis HLS ). It will need 110GB of disk space: if you uncheck Ultrascale , Ultrascale+ , Versal ACAP and Alveo acceleration platform , it will use less space and still work. Agree with everything and choose a directory to install (e.g. ~/Xilinx) Install and wait for hours... Setup a shell environment variable allowing to use the tools when necessary (add this to your ~/.bashrc , ~/.zshrc or whatever you're currently using, replacing $HOME/Xilinx by the directory you chose to install all the tools) export XILINX_ROOT_DIR=$HOME/Xilinx","title":"Vivado, Vitis &amp; Vitis HLS (2022.2 version)"},{"location":"syfala-installation/#installing-cable-drivers-on-linux","text":"go to: $XILINX_ROOT_DIR/Vivado/2022.2/data/xicom/cable_drivers/lin64/install_script/install_drivers directory run ./install_drivers run sudo cp 52-xilinx-digilent-usb.rules /etc/udev/rules.d , this allows JTAG connection through USB .","title":"Installing Cable Drivers on Linux"},{"location":"syfala-installation/#installing-digilent-board-files","text":"Download the board files here Open the folder extracted from the archive and navigate to its new/board_files folder. You will be copying all of this folder's subfolders go to $XILINX_ROOT_DIR/Vivado/2022.2/data/xhub/boards/XilinxBoardStore/boards/Xilinx Copy all of the folders found in vivado-boards new/board_files folder and paste them into this folder","title":"Installing Digilent Board Files"},{"location":"syfala-installation/#cloning-the-syfala-repository","text":"To clone and install the latest stable version of the Syfala toolchain, you can use the following commands: $ git clone https://github.com/inria-emeraude/syfala $ cd syfala $ ./syfala.tcl install $syfala --help In order to use the Syfala toolchain to compile your first example, please report to the main README file located in the repository's root directory.","title":"Cloning the Syfala repository"},{"location":"syfala-reference/","text":"Syfala reference General Option Flags option accepted values description --xversion 2020.2 - 2022.2 chooses Xilinx toolchain version (2020.2 & 2022.2 only supported for now) --reset / resets current build directory before building ( careful ! all files from previous build will be lost) 'One-shot' commands name description arguments install installs this script as a symlink in /usr/bin/ none clean deletes current build directory none import sets previously exported .zip build as the current build path to the .zip build export exports current build in a .zip file located in the 'export' directory name of the build report displays HLS or global report HLS | any demo fully builds demo based on default example (virtualAnalog.dsp) none flash flashes current build onto target device none gui executes the Faust-generated GUI application none open-project opens the generated .xpr project with Vivado none help prints list of available commands, options and run-time parameters none version displays the current script's version Run steps Note : the --all is not necessary if you wish to run all steps, just run syfala myfaustdsp.dsp --all runs all toolchain compilation steps (from --arch to --gui ) --arch uses Faust to generate ip/host cpp files for HLS and Host application compilation --hls runs Vitis HLS on generated ip cpp file --project generates Vivado project --synth synthesizes full Vivado project --host compiles Host application, exports sources and .elf output to build/sw_export --gui compiles Faust GUI control application --flash flashes boot files on device at the end of the run --report prints HLS report at the end of the run --export <id> exports build to export/ directory at the end of the run Run parameters parameter accepted values default value --memory, -m DDR - STATIC DDR --board, -b Z10 - Z20 - GENESYS Z10 --sample-rate 48000 - 96000 - 192000 - 384000 - 768000 48000 --sample-width 16 - 24 - 32 24 --controller-type DEMO - PCB1 - PCB2 - PCB3 - PCB4 PCB1 --ssm-volume FULL - HEADPHONE - DEFAULT DEFAULT --ssm-speed FAST - DEFAULT DEFAULT Parameter description parameter description --memory, -m selects if external DDR3 is used. Enable if you use some delay, disable if you do not want any memory access (should not be disabled) --board Defines target board. Z10 , Z20 and GENESYS only. If you have a VGA port (rather than 2 HDMI ports), you have an old Zybo version, which is not supported. --sample-rate Changes sample rate value (Hz). Only 48kHz and 96kHz is available for SSM embeded codec. 192000 ( ADAU1777 and ADAU1787 only) 384000 ( ADAU1787 only) 768000 ( ADAU1787 only and with --sample--width 16 only) --sample-width Defines sample bit depth (16|24|32) --controller-type Defines the controller used to drive the controls when SW3 is UP . ( SW3 DOWN for software control), SEE BELOW for details on each value --ssm-volume Chooses audio codec to use. For now, it only changes the scale factor. FULL : Maximum ( WARNING : for speaker only, do not use with headphones). HEADPHONE : Lower volume for headphone use. DEFAULT : Default value +1dB because the true 0dB ( 0b001111001 ) decreases the signal a little bit. --ssm-speed Changes SSM ADC/DAC sample rate. DEFAULT : 48kHz sample rate. FAST : 96Khz sample rate Hardware configuration (Zybo Z7-10/20) Syfala Hardware Controller Board (SW3 UP) If you use a Hardware Controller Board, please set the --controller-type command-line parameter to the proper value (see below) Controller-type values description DEMO : Popophone demo box PCB1 : Emeraude PCB config 1: 4 knobs, 2 switches, 2 sliders (default) PCB2 : Emeraude PCB config 2: 8 knobs PCB3 : Emeraude PCB config 3: 4 knobs, 4 switches PCB4 : Emeraude PCB config 4: 4 knobs above, 4 switches below You can swap from hardware to software controller during DSP execution by changing SW3 . Switch description Default configuration in bold SW3 SW2 SW1 SW0 +-----+-----+-------+------+ | Hard| ADAU| BYPASS| MUTE | | | | | | | | | | | | GUI | SSM | USE DSP | UNMUTE | +-----+-----+-------+------+ SW3 : Controller type select: hardware (Controller board) or software (GUI). SW2 : Audio codec input select (ADAU=external or SSM=onboard). Does not affect output. SW1 : Bypass audio dsp. SW0 : Mute. Status LEDs The RGB led indicate the program state: BLUE : waiting GREEN : all good! ORANGE : warning (bypass or mute enabled) RED : ERROR! (configuration failed or incompatible), could happen if you select the SSM codec with incompatible sample rate. The 4 LEDs above the switches indicate the switches state. If one of them blink, it indicates the source of the warning/error. SD card files You can put the program on an SD card (if you want something reproducible and easily launchable, for the demos...). After a make command, you should see a BOOT.bin file in SW_export (or you can build it with make boot_file ). Put the file on the root of SD card. And don't forget to put JP5 on 'SD' position !","title":"Syfala reference"},{"location":"syfala-reference/#syfala-reference","text":"","title":"Syfala reference"},{"location":"syfala-reference/#general-option-flags","text":"option accepted values description --xversion 2020.2 - 2022.2 chooses Xilinx toolchain version (2020.2 & 2022.2 only supported for now) --reset / resets current build directory before building ( careful ! all files from previous build will be lost)","title":"General Option Flags"},{"location":"syfala-reference/#one-shot-commands","text":"name description arguments install installs this script as a symlink in /usr/bin/ none clean deletes current build directory none import sets previously exported .zip build as the current build path to the .zip build export exports current build in a .zip file located in the 'export' directory name of the build report displays HLS or global report HLS | any demo fully builds demo based on default example (virtualAnalog.dsp) none flash flashes current build onto target device none gui executes the Faust-generated GUI application none open-project opens the generated .xpr project with Vivado none help prints list of available commands, options and run-time parameters none version displays the current script's version","title":"'One-shot' commands"},{"location":"syfala-reference/#run-steps","text":"Note : the --all is not necessary if you wish to run all steps, just run syfala myfaustdsp.dsp --all runs all toolchain compilation steps (from --arch to --gui ) --arch uses Faust to generate ip/host cpp files for HLS and Host application compilation --hls runs Vitis HLS on generated ip cpp file --project generates Vivado project --synth synthesizes full Vivado project --host compiles Host application, exports sources and .elf output to build/sw_export --gui compiles Faust GUI control application --flash flashes boot files on device at the end of the run --report prints HLS report at the end of the run --export <id> exports build to export/ directory at the end of the run","title":"Run steps"},{"location":"syfala-reference/#run-parameters","text":"parameter accepted values default value --memory, -m DDR - STATIC DDR --board, -b Z10 - Z20 - GENESYS Z10 --sample-rate 48000 - 96000 - 192000 - 384000 - 768000 48000 --sample-width 16 - 24 - 32 24 --controller-type DEMO - PCB1 - PCB2 - PCB3 - PCB4 PCB1 --ssm-volume FULL - HEADPHONE - DEFAULT DEFAULT --ssm-speed FAST - DEFAULT DEFAULT","title":"Run parameters"},{"location":"syfala-reference/#parameter-description","text":"parameter description --memory, -m selects if external DDR3 is used. Enable if you use some delay, disable if you do not want any memory access (should not be disabled) --board Defines target board. Z10 , Z20 and GENESYS only. If you have a VGA port (rather than 2 HDMI ports), you have an old Zybo version, which is not supported. --sample-rate Changes sample rate value (Hz). Only 48kHz and 96kHz is available for SSM embeded codec. 192000 ( ADAU1777 and ADAU1787 only) 384000 ( ADAU1787 only) 768000 ( ADAU1787 only and with --sample--width 16 only) --sample-width Defines sample bit depth (16|24|32) --controller-type Defines the controller used to drive the controls when SW3 is UP . ( SW3 DOWN for software control), SEE BELOW for details on each value --ssm-volume Chooses audio codec to use. For now, it only changes the scale factor. FULL : Maximum ( WARNING : for speaker only, do not use with headphones). HEADPHONE : Lower volume for headphone use. DEFAULT : Default value +1dB because the true 0dB ( 0b001111001 ) decreases the signal a little bit. --ssm-speed Changes SSM ADC/DAC sample rate. DEFAULT : 48kHz sample rate. FAST : 96Khz sample rate","title":"Parameter description"},{"location":"syfala-reference/#hardware-configuration-zybo-z7-1020","text":"","title":"Hardware configuration (Zybo Z7-10/20)"},{"location":"syfala-reference/#syfala-hardware-controller-board-sw3-up","text":"If you use a Hardware Controller Board, please set the --controller-type command-line parameter to the proper value (see below)","title":"Syfala Hardware Controller Board (SW3 UP)"},{"location":"syfala-reference/#controller-type-values-description","text":"DEMO : Popophone demo box PCB1 : Emeraude PCB config 1: 4 knobs, 2 switches, 2 sliders (default) PCB2 : Emeraude PCB config 2: 8 knobs PCB3 : Emeraude PCB config 3: 4 knobs, 4 switches PCB4 : Emeraude PCB config 4: 4 knobs above, 4 switches below You can swap from hardware to software controller during DSP execution by changing SW3 .","title":"Controller-type values description"},{"location":"syfala-reference/#switch-description","text":"Default configuration in bold SW3 SW2 SW1 SW0 +-----+-----+-------+------+ | Hard| ADAU| BYPASS| MUTE | | | | | | | | | | | | GUI | SSM | USE DSP | UNMUTE | +-----+-----+-------+------+ SW3 : Controller type select: hardware (Controller board) or software (GUI). SW2 : Audio codec input select (ADAU=external or SSM=onboard). Does not affect output. SW1 : Bypass audio dsp. SW0 : Mute.","title":"Switch description"},{"location":"syfala-reference/#status-leds","text":"The RGB led indicate the program state: BLUE : waiting GREEN : all good! ORANGE : warning (bypass or mute enabled) RED : ERROR! (configuration failed or incompatible), could happen if you select the SSM codec with incompatible sample rate. The 4 LEDs above the switches indicate the switches state. If one of them blink, it indicates the source of the warning/error.","title":"Status LEDs"},{"location":"syfala-reference/#sd-card-files","text":"You can put the program on an SD card (if you want something reproducible and easily launchable, for the demos...). After a make command, you should see a BOOT.bin file in SW_export (or you can build it with make boot_file ). Put the file on the root of SD card. And don't forget to put JP5 on 'SD' position !","title":"SD card files"},{"location":"using-syfala-containers/","text":"Using syfala containers Installing podman Archlinux: yay -S podman Ubuntu: sudo apt install podman macOS: brew install podman If shell shows these kind of errors: WARN[0000] Reading allowed ID mappings: reading subuid mappings for user \"user\" and subgid mappings for group \"user\": no subuid ranges found for user \"user\" in /etc/subuid WARN[0000] Found no UID ranges set aside for user \"user\" in /etc/subuid. WARN[0000] Found no GID ranges set aside for user \"user\" in /etc/subgid. do this (replace user by your username): $ sudo echo \"user:10000:65536\" >> /etc/subuid $ sudo echo \"user:10000:65536\" >> /etc/subgid Importing image The image is a .tar file with a specific structure, it is named syfala-debian.tar in our case. $ cd /path/to/parent/directory/of/image # import image (make sure you have 100+gb of space left on your machine) $ podman load -i syfala-debian.tar Running container without display $ podman run -ti --user=syfala --network=host -v /dev/usb:/dev/usb -v /dev/ttyUSB1:/dev/ttyUSB1:z syfala-debian /bin/bash with display (required for Vivado/Vitis GUI, and for the Faust UART GUI application): # first, allow X11 to share displays with local processes $ xhost +local: $ podman run -ti --user=syfala --network=host --env DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix:z -v /dev/dri:/dev/dri:z -v /dev/bus/usb:/dev/bus/usb -v /dev/ttyUSB1:/dev/ttyUSB1:z syfala-debian /bin/bash # once inside the container, you'll have to run: $ xhost + # you can now open vitis_hls, vivado, etc. running with chroot permissions to build the alpine-linux rootfs you'll just have to add --privileged to the podman run [...] command. Notes: -ti = --tty + --interactive --user=syfala - means you connect to the container as the user syfala (already registered), you can change that to user=root if needed. --network=host - not really sure yet why it's needed... --env DISPLAY=$DISPLAY - needed to share your X11 display ID -v /tmp/.X11-unix:/tmp/.X11-unix:z - needed to share your X11 display -v /dev/dri:/dev/dri:z - same -v /dev/usb:/dev/usb - needed in order to flash bitstream & application -v /dev/ttyUSB1:/dev/ttyUSB1 - needed in order to use the Faust GUI-UART application x2022-ubuntu1804-ctn - the name of the container you spawned from the image bash - it will open a bash session when accessing the container, you can replace that by any binary that you want to start","title":"Using syfala containers"},{"location":"using-syfala-containers/#using-syfala-containers","text":"","title":"Using syfala containers"},{"location":"using-syfala-containers/#installing-podman","text":"Archlinux: yay -S podman Ubuntu: sudo apt install podman macOS: brew install podman If shell shows these kind of errors: WARN[0000] Reading allowed ID mappings: reading subuid mappings for user \"user\" and subgid mappings for group \"user\": no subuid ranges found for user \"user\" in /etc/subuid WARN[0000] Found no UID ranges set aside for user \"user\" in /etc/subuid. WARN[0000] Found no GID ranges set aside for user \"user\" in /etc/subgid. do this (replace user by your username): $ sudo echo \"user:10000:65536\" >> /etc/subuid $ sudo echo \"user:10000:65536\" >> /etc/subgid","title":"Installing podman"},{"location":"using-syfala-containers/#importing-image","text":"The image is a .tar file with a specific structure, it is named syfala-debian.tar in our case. $ cd /path/to/parent/directory/of/image # import image (make sure you have 100+gb of space left on your machine) $ podman load -i syfala-debian.tar","title":"Importing image"},{"location":"using-syfala-containers/#running-container","text":"","title":"Running container"},{"location":"using-syfala-containers/#without-display","text":"$ podman run -ti --user=syfala --network=host -v /dev/usb:/dev/usb -v /dev/ttyUSB1:/dev/ttyUSB1:z syfala-debian /bin/bash","title":"without display"},{"location":"using-syfala-containers/#with-display-required-for-vivadovitis-gui-and-for-the-faust-uart-gui-application","text":"# first, allow X11 to share displays with local processes $ xhost +local: $ podman run -ti --user=syfala --network=host --env DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix:z -v /dev/dri:/dev/dri:z -v /dev/bus/usb:/dev/bus/usb -v /dev/ttyUSB1:/dev/ttyUSB1:z syfala-debian /bin/bash # once inside the container, you'll have to run: $ xhost + # you can now open vitis_hls, vivado, etc.","title":"with display (required for Vivado/Vitis GUI, and for the Faust UART GUI application):"},{"location":"using-syfala-containers/#running-with-chroot-permissions-to-build-the-alpine-linux-rootfs","text":"you'll just have to add --privileged to the podman run [...] command.","title":"running with chroot permissions to build the alpine-linux rootfs"},{"location":"using-syfala-containers/#notes","text":"-ti = --tty + --interactive --user=syfala - means you connect to the container as the user syfala (already registered), you can change that to user=root if needed. --network=host - not really sure yet why it's needed... --env DISPLAY=$DISPLAY - needed to share your X11 display ID -v /tmp/.X11-unix:/tmp/.X11-unix:z - needed to share your X11 display -v /dev/dri:/dev/dri:z - same -v /dev/usb:/dev/usb - needed in order to flash bitstream & application -v /dev/ttyUSB1:/dev/ttyUSB1 - needed in order to use the Faust GUI-UART application x2022-ubuntu1804-ctn - the name of the container you spawned from the image bash - it will open a bash session when accessing the container, you can replace that by any binary that you want to start","title":"Notes:"}]}